= Signal Methods =
Located [https://github.gatech.edu/emade/emade/blob/nlp-nn/src/GPFramework/signal_methods.py here] in EMADE github.

== Window Functions ==
=== Background ===
Signal processing typically uses a Fourier Transform to convert data captured in the time domain to the frequency domain. If a signal is captured in a periodic manner, the resulting signal has no leakage and requires no windowing (top). However, if the signal is captured in an aperiodic manner, there will be leakage and a window function is necessary (bottom).

[[files/Periodic.png]]
[[files/Aperiodic_signal.png]]

Below, the top plot shows sine in the frequency domain, with and without leakage. In the bottom plot, a Hann(ing) window is applied (window functions greatly reduce the effect of leakage in the frequency domain).

[[files/Sine_leak_vs_no_leak.png]]
[[files/Hanning_ex.png]]

=== Hann(ing) Window (raised Cosine) ===
The [https://ccrma.stanford.edu/~jos/sasp/Hann_Hanning_Raised_Cosine.html Hann window] is used for smoothing functions and is widely applicable. It is a raised cos function where the minima touch zero causing the second derivative discontinuities frame the window. Hann has a high roll-off rate.

[[files/Hanning_window.png]]

     def w_hann_setup(data, lag=True):
         N = data.shape[1]
         nVec = np.arange(N)
         if lag:
             w = 0.5*(1 - np.cos( (2*np.pi*nVec)/(N - 1) ) )
         else:
             w = 0.5*(1 + np.cos( (2*np.pi*nVec)/(N - 1) ) )
         return { "w": w }
     
     window_hann = smw.register("WindowHann", my_window, w_hann_setup, [bool], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_hann.__doc__ = """
     Performs a Hann (Hanning) window on a signal with or without "lag"
     Args:
         data: numpy array of example
         lag: whether to include lag
     Returns:
         Data with Hann window feature added
     """

=== Hamming Window ===
The [https://ccrma.stanford.edu/~jos/sasp/Hamming_Window.html Hamming window] is similar to the Hann window (raised cos) but uses optimal alpha and beta values to minimize the peak-side lobe level (see second figure below). This results in a very slow roll-off rate.

[[files/Hamming_window.png]]
     def w_hamming_setup(data, lag=True):
         N = data.shape[1]
         nVec = np.arange(N)
         alpha = 0.53836
         beta = 0.46164
         if lag:
             w = alpha - beta*np.cos( (2*np.pi*nVec)/(N-1) )
         else:
             w = alpha + beta*np.cos( (2*np.pi*nVec)/(N-1) )
         return { "w": w }
     
     window_hamming = smw.register("WindowHamming", my_window, w_hamming_setup, [bool], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_hamming.__doc__ = """
     Perfroms a Hamming window on a signal with or without "lag"
     Args:
         data: numpy array of example
         lag: whether to include lag
     Returns:
         Data with Hamming window feature added
     """

=== Cosine Window ===
Similar to Hann window but the sine function is not raised.
     def w_cosine_setup(data):
         N = data.shape[1]
         nVec = np.arange(N)
         w = np.sin( np.pi*nVec / (N-1) )
         return { "w": w }
     
     window_cosine = smw.register("WindowCosine", my_window, w_cosine_setup, [], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_cosine.__doc__ = """
     Performs a Cosine (Sine) window on a signal
     Args:
         data: numpy array of example
     Returns:
         Data with Cosine window feature added
     """

=== Tukey Window (tapered cosine) ===
The [https://sso.sandia.gov/idp/Authn/AuthMenu/menu?conversation=e1s1 Tukey window] is a mix of  a Hann window and rectangular window used to counteract smearing in a signal. This is applied when large dynamic ranges are expected or the spectrum is complex with multiple or distributed frequency content. Smearing occurs when a main lobe of a signal is offset and separated by nulls, causing "sidelobes" (see graphic below).

[[files/Smearing_Example_1.png]]

Tukey applied to a smeared signal.

[[files/Tukey.png]]
     def w_turkey_setup(data, alpha=0.5):
         alpha = float(alpha)
         N = data.shape[1]
         w = np.zeros(N)
         for i in np.arange(N):
             if i < alpha*(N-1)/2:
                 w[i] = 0.5*(1 + np.cos( np.pi * ( (2*i)/(alpha*(N-1)) - 1 ) ) )
             elif i <= (N-1)*(1-alpha/2):
                 w[i] = 1
             else:
                 w[i] = 0.5*(1 + np.cos( np.pi * ( (2*i)/(alpha*(N-1)) - 2/alpha + 1 ) ) )
         return { "w": w }
     
     window_turkey = smw.register("WindowTurkey", my_window, w_turkey_setup, [float], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_turkey.__doc__ = """
     Performs a Tukey window on a signal using a parameter alpha
     An alpha of 0 is a rectangular window
     An alpha of 1 is a Hann window
     Alpha should be between 0 and 1
     Args:
         data: numpy array of example
         alpha: type of window
     Returns:
         Data with Tukey window feature added
     """

=== Lanczos Window (scaled central sinc lobe) ===
The [https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=F3237AF44A9EBEA6B6B06F5BC7D43ED7?doi=10.1.1.116.7898&rep=rep1&type=pdf Lanczos window] is a normalized sinc function bounded by the central lobe of a longer sinc function - this is due to the fact that sinc never reaches 0 (but it approaches it slowly). Left is a sinc function and to the right is the Lanczos function.

[[files/Sinc_function.png]]

[[files/Lanczos_function.png]]
     def w_hamming_setup(data, lag=True):
         N = data.shape[1]
         nVec = np.arange(N)
         alpha = 0.53836
         beta = 0.46164
         if lag:
             w = alpha - beta*np.cos( (2*np.pi*nVec)/(N-1) )
         else:
             w = alpha + beta*np.cos( (2*np.pi*nVec)/(N-1) )
         return { "w": w }
     
     window_hamming = smw.register("WindowHamming", my_window, w_hamming_setup, [bool], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_hamming.__doc__ = """
     Perfroms a Hamming window on a signal with or without "lag"
     Args:
         data: numpy array of example
         lag: whether to include lag
     Returns:
         Data with Hamming window feature added
     """

=== Bartlett (Triangular) Window ===
The [https://prod-ng.sandia.gov/techlib-noauth/access-control.cgi/2017/174042.pdf Bartlett (triangle) window] tapers sidelobes off linearly.

Triangular:
[[files/Bartlett_triangle_window.png]]
     def w_triangular_setup(data):
         N = data.shape[1]
         nVec = np.arange(N)
         w = 2.0/(N+1)*( (N+1)/2.0 - np.abs(nVec - (N-1)/2.0 ) )
         return { "w": w }
     
     window_triangular = smw.register("WindowTriangular", my_window, w_triangular_setup, [], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_triangular.__doc__ = """
     Performs a triangular window on a signal
     Args:
         data: numpy array of example
     Returns:
         Data with triangular window feature added
     """

Bartlett:
     def w_bartlett_setup(data):
         N = data.shape[1]
         nVec = np.arange(N)
         w = 2.0/(N-1)*( (N-1)/2.0 - np.abs(nVec - (N-1)/2.0 ) )
         return { "w": w }
     
     window_bartlett = smw.register("WindowBartlett", my_window, w_bartlett_setup, [], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_bartlett.__doc__ = """
     Perfoms the Bartlet window on a signal
     Args:
         data: numpy array of example
     Returns:
         Data with Bartlet window feature added
     """

=== Gaussian Window ===
The familiar [https://ccrma.stanford.edu/~jos/sasp/Gaussian_Window_Transform_I.html Gaussian window] behaves as expected and smoothly tapers sidelobes.
     def w_gaussian_setup(data, sigma=1.0):
         sigma = float(sigma)
         N = data.shape[1]
         nVec = np.arange(N)
         w = np.exp( -0.5*( (nVec - (N-1)/2.0 )/( sigma*(N-1)/2.0 ) )**2 )
         return { "w": w }
     
     window_gaussian = smw.register("WindowGaussian", my_window, w_gaussian_setup, [float], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_gaussian.__doc__ = """
     Perfoms the Gaussian window on a signal
     Args:
         data: numpy array of example
         sigma: sigma value used by gaussian
     Returns:
         Data with Gaussian window feature added
     """

=== Blackman-Harris Window ===
The [https://ccrma.stanford.edu/~jos/sasp/Blackman_Harris_Window_Family.html Blackman-Harris window] is similar to the other windows but has a few defining features. Roll off is the same as Hann, it has three degrees of freedom (Hann has two), and one of them minimizes side lobes (similar to Hamming window). The classic Blackman window only has two degrees of freedom (no roll off factor).

[[files/Blackman_harris_window.png]]

Blackman-Harris:
     def w_blackman_harris_setup(data):
         a0 = 0.35875
         a1 = 0.48829
         a2 = 0.14128
         a3 = 0.01168
         N = data.shape[1]
         nVec = np.arange(N)
         w = a0 - a1*np.cos(2.0*np.pi*nVec/(N-1.0)) + a2*np.cos(4.0*np.pi*nVec/(N-1.0)) - a3*np.cos(6.0*np.pi*nVec/(N-1.0))
         return { "w": w }
     
     window_blackman_harris = smw.register("WindowBlackmanHarris", my_window, w_blackman_harris_setup, [], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_blackman_harris.__doc__ = """
     Perform a Blackman-Harris window on a dataset
     Args:
         data: numpy array of example
     Returns:
         Data with Blackman-Harris window feature added
     """

Classic Blackman:
     def w_blackman_setup(data, alpha=0.16):
         alpha = float(alpha)
         a0 = (1-alpha)/2.0
         a1 = 0.5
         a2 = alpha/2.0
         N = data.shape[1]
         nVec = np.arange(N)
         w = a0 - a1 * np.cos( (2*np.pi*nVec)/( N-1 ) ) + a2 * np.cos( (4*np.pi*nVec)/( N-1 ) )
         return { "w": w }
     
     window_blackman = smw.register("WindowBlackman", my_window, w_blackman_setup, [float], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_blackman.__doc__ = """
     Perfoms the Blackman window on a signal
     Args:
         data: numpy array of example
         alpha: equation parameter
     Returns:
         Data with Blackman window feature added
     """

=== Nuttall Window ===
[https://prod-ng.sandia.gov/techlib-noauth/access-control.cgi/2017/174042.pdf Nuttall window] functions are in the Blackman-Harris family where the coefficients are chosen to get specific characteristics. See table below for coefficients and resulting functions.

[[files/Nuttall.png]]
     def w_nuttall_setup(data):
         a0 = 0.355768
         a1 = 0.487396
         a2 = 0.144232
         a3 = 0.012604
         N = data.shape[1]
         nVec = np.arange(N)
         w = a0 - a1*np.cos(2.0*np.pi*nVec/(N-1.0)) + a2*np.cos(4.0*np.pi*nVec/(N-1.0)) - a3*np.cos(6.0*np.pi*nVec/(N-1.0))
         return { "w": w }
     
     window_nuttall = smw.register("WindowNuttal", my_window, w_nuttall_setup, [], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_nuttall.__doc__ = """
     Perform a Nuttall window on a dataset
     Args:
         data: numpy array of example
     Returns:
         Data with Nuttall window feature added
     """

=== Kaiser Window ===
The [https://ccrma.stanford.edu/~jos/sasp/Kaiser_Window.html Kaiser window] is an approximation of the DPSS (Discrete Prolate Spheroidal Sequence) using Bessel functions. DPSS maximizes the signal in the central lobe. Below are examples of the Kaiser window with different values of alpha (note the side lobes rolling off faster as alpha increases).

[[files/Kaiser.png]]
     def w_kaiser_setup(data, alpha=3.0, lag=True):
         # Not sure on alpha range on this one
         if alpha < 0:
             alpha = 0
         alpha = float(alpha)
     
         N = data.shape[1]
         nVec = np.arange(N)
         if lag:
             w = np.i0(np.pi*alpha*np.sqrt(1 - ( 2.0*nVec/(N-1) - 1)**2) ) / np.i0(np.pi*alpha)
         else:
             w = np.i0(np.pi*alpha*np.sqrt(1 - ( 2.0*nVec/(N-1) )**2) ) / np.i0(np.pi*alpha)
         return { "w": w }
     
     window_kaiser = smw.register("WindowKaiser", my_window, w_kaiser_setup, [float, bool], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_kaiser.__doc__ = """
     Performs a Kaiser window on a signal with or without lag,
     given a parameter alpha. Alpha is usually 3
     Args:
         data: numpy array of example
         alpha: equation parameter
         lag: whether to include lag
     Returns:
         Data with Kaiser window feature added
     """

=== Planck-taper Window ===
The [https://www.recordingblogs.com/wiki/planck-taper-window Planck window] is similar to a rectangular window but with rounded corners. To the left is the Planck window with varying coefficients and to the right are the magnitude responses.

[[files/Planck.png]]
     def w_planck_taper_setup(data, epsilon=0.1):
         # Not sure if this needs to be bounded either
         if epsilon < 0:
             epsilon = 0
     
         N = data.shape[1]
         nVec = np.arange(N)
         Zplus = 2.0*epsilon*(1.0/(1+2.0*nVec/(N-1.0)) + 1.0/(1.0-2.0*epsilon+2.0*nVec/(N-1.0)))
         Zminus = 2.0*epsilon*(1.0/(1-2.0*nVec/(N-1.0)) + 1.0/(1.0-2.0*epsilon-2.0*nVec/(N-1.0)))
         w = np.zeros(N)
         for i in np.arange(N):
             if i < epsilon*(N-1):
                 w[i] = 1.0/(np.exp(Zplus[i]) + 1.0)
             elif i < (1.0-epsilon)*(N-1.0):
                 w[i] = 1.0
             elif i <= (N-1.0):
                 w[i] = 1.0/(np.exp(Zminus[i]) + 1.0)
             else:
                 w[i] = 0.0
         return { "w": w }
     
     window_planck_taper = smw.register("WindowPlanckTaper", my_window, w_planck_taper_setup, [float], [FEATURES_TO_FEATURES, STREAM_TO_STREAM])
     window_planck_taper.__doc__ = """
     Performs a Planck-taper window on a signal, given a parameter epsilon
     Epsilon is 0.1 on wikipedia
     Args:
         data: numpy array of example
         epsilon: equation parameter
     Returns:
         Data with Planck-taper window feature added
     """

== Filter Functions ==
=== Adaptive Thresholding ===
[https://docs.opencv.org/master/d7/d4d/tutorial_py_thresholding.html Adaptive thresholding] determines the threshold for a pixel based on a small region around it (rather than globally). This allows for images with non-uniform lighting to be processed appropriately. See below for an example using a sudoku puzzle.

[[files/Ada_threshold.jpg]]

=== Otsu's Binarization ===
[https://docs.opencv.org/master/d7/d4d/tutorial_py_thresholding.html Otsu's Binarization] is an adaptive thresholding algorithm that maximizes the inter-class variance (or conversely, minimize the weighted in-class variance) to set a global threshold. This algorithm works well with images that have a distinct foreground and background (a bi-modal distribution in pixel intensity). See here for a [https://en.wikipedia.org/wiki/Otsu%27s_method#/media/files/Otsu%27s_Method_Visualization.gif visualization] of the algorithm.

     def otsu_binary_threshold_helper(data, max_value=255):
         ret, thresh = cv2.threshold(data, 0, max_value, cv2.THRESH_BINARY_INV+cv2.THRESH_OTSU)
         return thresh
     otsu_binary_threshold = smw.register("OtsuBinaryThreshold", "test_otsu_binary_threshold", otsu_binary_threshold_helper, None, [int], TRI_STATE)
     otsu_binary_threshold.__doc__ = """
     Otsu's binarization (binary threshold)
     Thresholds all values to either zero or max_value
     Args:
         data: numpy array of example
         max_value: maximum value after threshold is performed
     Returns:
         Transformed data
     """


== Spatial Methods ==
Located [https://github.gatech.edu/emade/emade/blob/nlp-nn/src/GPFramework/spatial_methods.py here].

=== Morphological Functions ===
[https://docs.opencv.org/master/d9/d61/tutorial_py_morphological_ops.html Morphological functions] perform transformations on binary images using their shape. A kernel (or structuring element) is used to determine what operation will be applied. Below is an example image and two common kernels applied (erosion and dilation).

[[files/Morph_ex.png]]

Combinations of kernels can be used to apply additional effects. Opening is erosion followed by dilation (left). Closing is the reverse operation (right). Additionally, Blackhat and other kernels build off of closing and opening by subtracting the result from the input image.

[[files/Morph_open_close.png]]

==== Erosion ====
Erosion erodes (changing white pixels to black) the foreground boundaries (adjusted by kernel size).

Rectangle:
     def morph_erosion_rect_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_RECT
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.erode(data, kernel, iterations=iterations)
         return data
     
     morph_erosion_rect = smw.register("MorphErosionRect", morph_erosion_rect_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_erosion_rect.__doc__ = """
     Perform morphological erosion on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """

Ellipse:
     def morph_erosion_ellipse_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_ELLIPSE
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.erode(data, kernel, iterations=iterations)
         return data
     
     morph_erosion_ellipse = smw.register("MorphErosionEllipse", morph_erosion_ellipse_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_erosion_ellipse.__doc__ = """
     Perform morphological erosion on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """

Cross:
     def morph_erosion_cross_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_CROSS
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.erode(data, kernel, iterations=iterations)
         return data
     
     morph_erosion_cross = smw.register("MorphErosionCross", morph_erosion_cross_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_erosion_cross.__doc__ = """
     Perform morphological erosion on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """


==== Dilation ====
Dilation expands the foreground object by dilating (changing black pixels to white) background pixels at the boundary of the foreground.

Rectangle:
     def morph_dilate_rect_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_RECT
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.dilate(data, kernel, iterations=iterations)
         return data
     
     morph_dilate_rect = smw.register("MorphDilateRect", morph_dilate_rect_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_dilate_rect.__doc__ = """
     Perform morphological dilation on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """

Ellipse:
     def morph_dilate_ellipse_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_ELLIPSE
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.dilate(data, kernel, iterations=iterations)
         return data
     
     morph_dilate_ellipse = smw.register("MorphDilateEllipse", morph_dilate_ellipse_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_dilate_ellipse.__doc__ = """
     Perform morphological dilation on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """

Cross:
     def morph_dilate_cross_helper(data, kernel_x=5, kernel_y=5, iterations=1):
         kernel_type = cv2.MORPH_CROSS
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.dilate(data, kernel, iterations=iterations)
         return data
     
     morph_dilate_cross = smw.register("MorphDilateCross", morph_dilate_cross_helper, morph_setup, [int, int, int], TRI_STATE)
     morph_dilate_cross.__doc__ = """
     Perform morphological dilation on image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
         iterations: positive integer the number of times to apply the
         morphological operation
     Returns:
         Transformed data
     """
==== Opening ====
Opening is erosion followed by dilation.

Rectangle:
     def morph_open_rect_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_RECT
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_OPEN, kernel)
         return data
     
     morph_open_rect = smw.register("MorphOpenRect", morph_open_rect_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_open_rect.__doc__ = """
     Perform morphological opening on image. opening is erosion
     followed by dilation
     Useful for removing noise
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Ellipse:
     def morph_open_ellipse_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_ELLIPSE
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_OPEN, kernel)
         return data
     
     morph_open_ellipse = smw.register("MorphOpenEllipse", morph_open_ellipse_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_open_ellipse.__doc__ = """
     Perform morphological opening on image. opening is erosion
     followed by dilation
     Useful for removing noise
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Cross:
     def morph_open_cross_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_CROSS
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_OPEN, kernel)
         return data
     
     morph_open_cross = smw.register("MorphOpenCross", morph_open_cross_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_open_cross.__doc__ = """
     Perform morphological opening on image. opening is erosion
     followed by dilation
     Useful for removing noise
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

==== Closing ====
Closing is dilation followed by erosion.

Rectangle:
     def morph_close_rect_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_RECT
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_CLOSE, kernel)
         return data
     
     morph_close_rect = smw.register("MorphCloseRect", morph_close_rect_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_close_rect.__doc__ = """
     Perform morphological close on image. closing is dilation
     followed by erosion
     Useful for filling in holes in the foreground image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Ellipse:
     def morph_close_ellipse_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_ELLIPSE
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_CLOSE, kernel)
         return data
     
     morph_close_ellipse = smw.register("MorphCloseEllipse", morph_close_ellipse_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_close_ellipse.__doc__ = """
     Perform morphological close on image. closing is dilation
     followed by erosion
     Useful for filling in holes in the foreground image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Cross:
     def morph_close_cross_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_CROSS
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_CLOSE, kernel)
         return data
     
     morph_close_cross = smw.register("MorphCloseCross", morph_close_cross_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_close_cross.__doc__ = """
     Perform morphological close on image. closing is dilation
     followed by erosion
     Useful for filling in holes in the foreground image
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

==== Gradient ====
Gradient is the difference between dilation and erosion of an image.

[[files/Gradient.png]]

Rectangle:
     def morph_gradient_rect_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_RECT
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_GRADIENT, kernel)
         return data
     
     morph_gradient_rect = smw.register("MorphGradientRect", morph_gradient_rect_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_gradient_rect.__doc__ = """
     Perform morphological gradient on image. Difference between
     dilation and erosion.
     Results look like the outline of an object
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Ellipse:
     def morph_gradient_ellipse_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_ELLIPSE
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_GRADIENT, kernel)
         return data
     
     morph_gradient_ellipse = smw.register("MorphGradientEllipse", morph_gradient_ellipse_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_gradient_ellipse.__doc__ = """
     Perform morphological gradient on image. Difference between
     dilation and erosion.
     Results look like the outline of an object
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """

Cross:
     def morph_gradient_cross_helper(data, kernel_x=5, kernel_y=5):
         kernel_type = cv2.MORPH_CROSS
         kernel = cv2.getStructuringElement(kernel_type, (kernel_x, kernel_y))
         data = cv2.morphologyEx(data, cv2.MORPH_GRADIENT, kernel)
         return data
     
     morph_gradient_cross = smw.register("MorphGradientCross", morph_gradient_cross_helper, morph_setup_reduced, [int, int], TRI_STATE)
     morph_gradient_cross.__doc__ = """
     Perform morphological gradient on image. Difference between
     dilation and erosion.
     Results look like the outline of an object
     Args:
         data: numpy array of example
         kernel_x: positive odd integer length of the kernel's x axis
         kernel_y: positive odd integer length of the kernel's y axis
     Returns:
         Transformed data
     """


=== Bitwise Logic Operators ===
[http://datahacker.rs/005-image-arithmetic-and-logical-operations-in-opencv-with-python/ Bitwise Logic Operators] are used on black and white images for a variety of applications; pattern recognition across multiple images (such as Raven's Progressive Matrices), masking regions of an image (to exclude extraneous information or detect objects), or to alter an image (by using a global value as an argument instead of a second image). The image below shows the four basic operators and their respective outputs. 

[[files/Bitwise.png]]

==== AND ====
     def bitwise_and_helper(data, second_data):
         return cv2.bitwise_and(data, second_data)
     
     bitwise_and = smw_2.register("BitwiseAnd", bitwise_and_helper, None, [], TRI_STATE)
     bitwise_and.__doc__ = """
     Calculates the per-element bit-wise conjunction of two arrays
     or an array and a scalar
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== NOT ====
     def bitwise_not_helper(data):
         return cv2.bitwise_not(data)
     
     bitwise_not = smw.register("BitwiseNOT", bitwise_not_helper, None, [], TRI_STATE)
     bitwise_not.__doc__ = """
     Inverts every bit of an array
     Args:
         data: numpy array of example
     Returns:
         Transformed data
     """

==== OR ====
     def bitwise_or_helper(data, second_data):
         return cv2.bitwise_or(data, second_data)
     
     bitwise_or = smw_2.register("BitwiseOr", bitwise_or_helper, None, [], TRI_STATE)
     bitwise_or.__doc__ = """
     Calculates the per-element bit-wise disjunction of two arrays
     or an array and a scalar
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== XOR ====
     def bitwise_xor_helper(data, second_data):
         return cv2.bitwise_xor(data, second_data)
     
     bitwise_xor = smw_2.register("BitwiseOr", bitwise_xor_helper, None, [], TRI_STATE)
     bitwise_xor.__doc__ = """
     Calculates the bitwize exclusive or
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

=== Image Math ===
Image math allows numerous [http://www.cs.cornell.edu/courses/cs4670/2020sp/linear-algebra-tutorial.pdf transformations] (image and transformation matrix, top image) and [https://kdr2.com/tech/main/1810-elewise-matrix-op-opencv.html layering] (image and image, bottom image).

[[files/Image_math_intro.png]]

==== Absolute Difference ====
     def absdiff_helper(data, second_data):
         return cv2.absdiff(data, second_data)
     
     absdiff = smw_2.register("AbsDiff", absdiff_helper, None, [], TRI_STATE)
     absdiff.__doc__ = """
     Calculates the per-element absolute difference between two arrays or
     between an array and a scalar
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== Add Helper ====
     def cv2_add_helper(data, second_data):
         return cv2.add(data, second_data)
     
     cv2_add = smw_2.register("Cv2Add", cv2_add_helper, None, [], TRI_STATE)
     cv2_add.__doc__ = """
     Add second_pair to data_pair. Data contains the sum
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== Add Weighted Helper ====
     def cv2_add_weighted_helper(data, second_data, alpha=1, beta=0):
         return cv2.addWeighted(data, alpha, second_data, beta, gamma=0)
     
     cv2_add_weighted = smw_2.register("Cv2AddWeighted", cv2_add_weighted_helper, None, [int, int], TRI_STATE)
     cv2_add_weighted.__doc__ = """
     Calculates the weighted sum of two arrays
     Args:
         data: given numpy array
         second_data: given numpy array
         alpha: weight assigned to data
         beta: weight assigned to second_data
     Returns:
         Transformed data
     """

==== Subtract Helper ====
     def cv2_subtract_helper(data, second_data):
         return cv2.subtract(data, second_data)
     
     cv2_subtract = smw_2.register("Cv2Subtract", cv2_subtract_helper, None, [], TRI_STATE)
     cv2_subtract.__doc__ = """
     Subtract second_pair to data_pair. Data contains the result
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== Subtract Saturate Helper ====
     def subtract_saturate_helper(data, second_data):
         (xmax, ymax) = data.shape
         for x in range(0,xmax):
             for y in range(0,ymax):
                 diff = data[x,y] - second_data[x,y]
                 if diff < 0:
                     data[x,y] = 0
                 else:
                     data[x,y] = diff
         return data
     
     subtract_saturate = smw_2.register("SubtractSaturate", subtract_saturate_helper, None, [], TRI_STATE)
     subtract_saturate.__doc__ = """
     Subtract second_pair to data_pair. Data contains the result
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== Multiply Helper ====
     def cv2_multiply_helper(data, second_data):
         return cv2.multiply(data, second_data)
     
     cv2_multiply = smw_2.register("Cv2Multiply", cv2_multiply_helper, None, [], TRI_STATE)
     cv2_multiply.__doc__ = """
     Multiply second_pair to data_pair. Data contains the result
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

==== Multiply Transposed Helper ====
     def multiply_transposed_helper(data, aTa=True):
         return cv2.mulTransposed(data, aTa=aTa)
     
     multiply_transposed = smw.register("MultiplyTransposed", multiply_transposed_helper, None, [bool], TRI_STATE)
     multiply_transposed.__doc__ = """
     Calculates the product of a matrix and its transposition
     (data_pair)transpose(data_pair)
     Args:
         data: numpy array of example
     Returns:
         Transformed data
     """

==== Random Uniform Helper ====
     def random_uniform_helper(data, low=0, high=255):
         return cv2.randu(data, low, high)
     
     random_uniform = smw.register("RandomUniform", random_uniform_helper, None, [int, int], TRI_STATE)
     random_uniform.__doc__ = """
     Generates a single uniformly-distributed random number or an array of
     random numbers
     Args:
         data: numpy array of example
         low: Inclusive lower boundary of the generated random numbers
         high: Exclusive upper boundary of the generated random numbers
     Returns:
         Transformed data
     """

==== Random Normal Helper ====
     def random_normal_helper(data, normal_mean=128, std_dev=1):
         return cv2.randn(data, normal_mean, std_dev)
     
     random_normal = smw.register("RandomNormal", random_normal_helper, None, [int, int], TRI_STATE)
     random_normal.__doc__ = """
     Generates a single normally distributed random number or an array of
     random numbers
     Args:
         data: numpy array of example
         normal_mean: the average
         std_dev: the standard deviation
     Returns:
         Transformed data
     """

==== Random Shuffle Helper ====
     def random_shuffle_helper(data):
         return cv2.randShuffle(data)
     
     random_shuffle = smw.register("RandomShuffle", random_shuffle_helper, None, [], TRI_STATE)
     random_shuffle.__doc__ = """
     Shuffles the array elements randomly
     Args:
         data: numpy array of example
     Returns:
         Transformed data
     """

==== Square Root Helper ====
     def cv2_sqrt_helper(data):
         return cv2.sqrt(data)
     
     cv2_sqrt = smw.register("Cv2Sqrt", cv2_sqrt_helper, None, [], TRI_STATE)
     cv2_sqrt.__doc__ = """
     Calculates the square root
     Args:
         data: numpy array of example
     Returns:
         Transformed data
     """

==== Divide Helper ====
     def cv2_divide_helper(data, second_data):
         return cv2.divide(data, second_data)
     
     cv2_divide = smw_2.register("Cv2Divide", cv2_divide_helper, None, [], TRI_STATE)
     cv2_divide.__doc__ = """
     Divide second_pair to data_pair. Data contains the result
     Args:
         data: given numpy array
         second_data: given numpy array
     Returns:
         Transformed data
     """

=== Scalar Math ===
[https://kdr2.com/tech/main/1810-elewise-matrix-op-opencv.html Scalar math] allows brightening, darkening, and biasing of images.

[[files/Scalar_math_intro.png]]

==== Add ====
     def scalar_add_helper(data, scalar=1.0):
         return cv2.add(data, scalar)
     
     scalar_add = smw.register("ScalarAdd", scalar_add_helper, None, [float], TRI_STATE)
     scalar_add.__doc__ = """
     Add a scalar value to each element of an array
     Args:
         data: numpy array of example
         scalar: value to add
     Returns:
        Transformed data
     """

==== Subtract ====
     def scalar_subtract_helper(data, scalar=1.0):
         return cv2.subtract(data, scalar)
     
     scalar_subtract = smw.register("ScalarSubtract", scalar_subtract_helper, None, [float], TRI_STATE)
     scalar_subtract.__doc__ = """
     Subtract a scalar value to each element of an array
     Args:
         data: numpy array of example
         scalar: value to add
     Returns:
         Transformed data
     """

==== Multiply ====
     def scalar_multiply_helper(data, scalar=2.0):
         return cv2.multiply(data, scalar)
     
     scalar_multiply = smw.register("ScalarMultiply", scalar_multiply_helper, None, [float], TRI_STATE)
     scalar_multiply.__doc__ = """
     Multiply a scalar value to each element of an array
     Args:
         data: numpy array of example
         scalar: value to add
     Returns:
         Transformed data
     """

==== Divide ====
     def scalar_divide_helper(data, scalar=2.0):
         return cv2.divide(data, scalar)
     
     scalar_divide = smw.register("ScalarDivide", scalar_divide_helper, None, [float], TRI_STATE)
     scalar_divide.__doc__ = """
     Divide a scalar value to each element of an array
     Args:
         data: numpy array of example
         scalar: value to add
     Returns:
         Transformed data
     """