'''Name:''' Austin T. Peng

'''Email:''' [mailto:apeng39@gatech.edu apeng39@gatech.edu]

'''Cell Phone:''' 510-364-3210

'''Interests:''' Machine Learning, [https://sites.google.com/view/gtclubtennis Tennis], Traveling, Cooking

= Fall 2021 =
== Week 2: September 1, 2021 ==
=== Lecture Notes ===
* Tree Representation
** nodes are called primitives and represent functions
** leaves are called terminals and represent parameters
** the output is produced at the root of the tree
** the tree is converted to a lisp preordered parse tree
* Crossover In Genetic Programming (GP)
** crossover in tree-based GP is simply exchanging subtrees
* Mutation In GP
** Inserting a node or subtree
** Deleting a node or subtree
** Changing a node
* Evaluating A Tree
** we feed a number of input points to get outputs
* What Can Make Evolution Easier?
** if we had better primitives, it would be easier to evolve algorithms
** ex. if we wanted to approximate sin(x), we could use +,-,*,/, but we could also use factorial, exponent, summation, etc.

=== Lab 2 ===

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Format Notebook (code, images)
|
|September 1, 2021
|September 8, 2021
|
|-
|Lab 2
|
|September 1, 2021
|September 8, 2021
|
|}


== Week 1: August 25, 2021 ==
=== Lecture Notes ===
* The concept of genetic algorithms is that each new generation of algorithms is created through the mating or mutation of individuals in the previous population. Through manny iterations of this process, it produces the best individual.
* Mating or crossover is the creation of a new algorithm using a specified number of parts of the previous algorithm depending on the number of split points.
* A mutation introduces random modifications to the algorithm in order to help maintain diversity.
* A simple genetic algorithm problem is the One Max problem which essentially wants to produce a list of all 1's given a list of binary numbers.

=== Keywords ===
* '''individual''': one specific candidate in the population (with properties like DNA)
* '''population''': group of individuals whose properties will be altered
* '''objective''': a value used to characterize individuals that you are trying to maximize or minimize (goal is ot inncrease objective through evolutionary algorithm)
* '''fitness''': relative comparison to other individuals; how well does the individual accomplish the task relative to the rest of the population?
* '''evaluation''': a function that computes the objective of an individual
* '''selection''': represents 'survival of hte fittest'; gives preference to better individuals, allowing them to pass on their genes
	- **fitness proportionate**: the greater the fitnenss value, the higher the probability of beingn selected for mating
	- **tournament**: several tournaments among individuals (number of individuals in each tournament is dependent on the tournament size); winners are selected for mating
* '''mate/crossover''': represents mating between individuals
![[files/apeng39/w1-ss1-crossover.png]]
![[files/apeng/w1-ss2-crossover.png]]
** anything up to n-point crossover is possible
* '''mutate''': introduces random modifications; purpose is to maintain diversity
![[files/apeng39/w1-ss3-mutate.png]]
* '''algorithms''': various evolutionary algorithms to create a solution or best individual

=== Lab 1 ===
==== Part 1: One Max Problem ====
* The objective of this problem is to create a genetic algorithm that returns the maximum amount of 1s in a binary list of size n.
** When I ran the algorithm with a much larger population (n=10000) it seemed like it took less generations for the an individual in the population to reach maximum fitness.

==== Part 2: N Queens Problem ====
* Learning Points
** Python map(function, iterable) takes a function and maps an iterable (tuple, list, etc.) to it
** Python zip() takes in iterables and returns an iterator of tuples with each tuple having elements from all the iterables
** Python slicing arr[start:stop:step] (start through not past stop, by step)
** arr[:] makes a shallow copy of the array
** you can resize an array to a desired length using [0] * size

* My Mutation Methods
 <nowiki>Start with a space in the first column,
(before the <nowiki>).

Then your block format will be
    maintained.

This is good for copying in code blocks:

def function():
    """documentation string"""

    if True:
        print True
    else:
        print False</nowiki>

 <nowiki>def mutOppositeHalves(individual, indpb):
    """ Randomly picks two indexes from each half of the individual and swaps them with a probability of indpb.
    
    :param individual: Individual to be mutated.
    :param indpb: Independent probability for each attribute to be exchanged to
                  another position.
    :returns: A tuple of one individual.
    """
    
    size = len(individual)
    front_half = random.randint(0, size/2)
    back_half = random.randint(size/2, size-1)
        
    individual[front_half], individual[back_half] = individual[back_half], individual[front_half]
    return individual,</nowiki>

 <nowiki>def mutRandomHalves(individual, indpb):
    """ Randomly picks a "midpoint" from the individual and picks two indexes from each half of midpoint,
     swapping them with a probability of indpb.
    
    :param individual: Individual to be mutated.
    :param indpb: Independent probability for each attribute to be exchanged to
                  another position.
    :returns: A tuple of one individual.
    """
    
    size = len(individual)
    midpoint = random.randint(0, size-2)
    
    front_half = random.randint(0, size/2)
    back_half = random.randint(size/2, size-1)
        
    individual[front_half], individual[back_half] = individual[back_half], individual[front_half]
    return individual,</nowiki>
* Observations & Reflection
** To test the effectiveness of my mutation methods, I ran each evolution (100 generations) 100 times and plotted the fitness values.
** I saw that my mutOppositeHalves() method performed the best, finding the global minimum of 0, 60 out of 100 evolutions. My mutRandomHalves() and the provided mutShuffleIndexes performed slightly worse producing the global minimum approximately 55 times out of 100 evolutions.
** However, for the methods I wrote, the maximum shown on the line graphs for each generation ended to be lower than the method provided.
** I struggled a bit with writing the code to make a bar graph using matplotlib mainly because of the data types that the toolbox returned. I kept feeding matplotlib a list of tuples when it wanted a list of ints.

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Install DEAP
|Completed
|August 25, 2021
|September 1, 2021
|August 26, 2021
|-
|Lab 1
|Completed
|August 25, 2021
|September 1, 2021
|September 1, 2021
|-
|Update Notebook
|Completed
|August 25, 2021
|September 1, 2021
|September 1, 2021
|}

