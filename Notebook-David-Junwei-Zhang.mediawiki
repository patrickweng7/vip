== Team Member Info ==
Team Member: David Zhang

Email: dzhang351@gatech.edu

Interests: Machine Learning, Optimization, Tennis


== August 25, 2021 ==

'''Team Meeting Notes'''

Lecture 1: Genetic Programming Introduction

Algorithm idea: each generation is created through mating/mutation of individuals in the previous population. Through numerous operations of this process, the fitness of the population will be optimized.

Keywords and Concepts

* Individual vs Population (population composed of individuals) 
* Objective: performance measure of an individual (goal is to maximize objective) 
* Fitness: relative measure of performance in comparison to other individuals 
* Selection: represents “survival of the fittest” 
* Fitness Proportionate: the greater fitness value, the higher probability of being selected for mating 
* Tournament: several tournaments among individuals determine selection 
* Mate/Crossover: represents mating between individuals 
** ie: Single point, double point crossover
* Mutation: introduces random modifications (to maintain diversity) 
** ie: Bit flip 

Genetic Algorithm Steps

# Randomly initialize population 
# Determine fitness 
# Repeat until fitness is good enough
## Select parent from population
## Perform mating/crossover
## Mutation
## Determine new fitness

*Types of problem that are good for genetic programming: problems with highly discontinuous, large search spaces 

'''Lab 1'''

One Max Problem

Objective: The population is a string of bits and we are trying to maximize the number of 1 bits within the population.
To maximize a single objective using DEAP, we can use the following line of code

<code> creator.create("FitnessMax", base.Fitness, weights=(1.0,)) </code>

Conversely, in order to minimize a single objective, we can set the weight tuple to (-1.0,) and to create a multi-objective problem, we can set the tuple to (1.0, 1.0)

Some settings used for the one max problem include
* using 2 points crossover function
* mutation with probability 0.05
* tournament selection with tournament size 3 (we use tournament selection because it tends to preserve more diverse traits than simple competition against the entire population
* running the algorithm for 40 generations on a population of 300

Summary

After running the final output 5 times, I got a score of 100 3 times, and 99 2 times. This means that for the most part, my algorithm converged to the best possible population with its optimal population but not always since we only run the algorithm for 40 generations. 

N-Queens Problem

* Objective: we are minimizing the number of queen conflicts on a chess board where conflicts only occur on the diagonals in this problem.
* A permutation is used to define our sample space where each value represents the column of the queen on row i
* We apply partially matched crossover for mating (instead of 2 point)
* For mutation, we cannot directly alter the values, but we instead shuffle indices (in order to preserve board constraints)

Custom Mutate Function (swapping 2 indices)

    #swaps two indices instead of one
    def mutate2(individual, indpb):
        size = len(individual)
        for i in range(size-1):
            if random.random() < indpb:
                swap_indx1 = random.randint(0, size - 2)
                swap_indx2 = random.randint(0, size - 2)
                if swap_indx1 >= i:
                    swap_indx1 += 1
                if swap_indx2 >= i:
                    swap_indx2 += 1
                individual[i], individual[swap_indx1] = \
                    individual[swap_indx1], individual[i]
                individual[i+1], individual[swap_indx2] = \
                    individual[swap_indx2], individual[i+1]
        return individual,

After applying the custom mutate function that swaps more indices, it appears to perform relatively the same as the original mutate function (this is because mutate doesn't happen often and only swapping 2 indices is not a major change from the original)

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Review Class Notes
|Completed
|August 25, 2021
|September 1, 2021
|August 26, 2021
|-
|Install Jupyter notebook and dependencies
|Completed
|August 25, 2021
|September 1, 2021
|August 28, 2021
|-
|Complete Lab 1
|In progress
|August 25, 2021
|September 1, 2021
|August 31, 2021
|-
|}
