== Team Member ==
[[files/ProfilePicture.jpg|thumb]]
Team Member: Kevin Zheng

Email: kzheng74@gatech.edu

Cell Phone: 256-468-0553

Interests: Artificial Intelligence
== September 6, 2021 ==
* NLP Problems
** Research Papers
*** find online resources and research papers to familiarize myself with how NLP generally works
** Question and Answer
*** the first task to work on would be a question/answer algorithm

* Subteam Meeting Notes
** Base research off of state-of-the-art NLP models like BERT
** SSH into PACE-ICE
** Follow Cameron's video to start a database server and start an EMADE run

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|SSH into PACE-ICE
|Complete
|September 6, 2021
|September 6, 2021
|September 13, 2021
|-
|Start database server on PACE
|In Progress
|September 6, 2021
|
|September 13, 2021
|-
|Run EMADE on PACE
|In Progress
|September 6, 2021
|
|September 13, 2021
|-
|Run EMADE on PACE
|In Progress
|September 6, 2021
|
|September 13, 2021
|-
|Read research papers about BERT
|In Progress
|September 6, 2021
|
|September 13, 2021
|}

== August 30, 2021 ==
* Discuss ideas
* Rank team choices

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Sync up with my assigned team members.
|Complete
|August 30, 2021
|September 6, 2021
|September 6, 2021
|}

== August 23, 2021 ==
* Brainstorming Infrastructure
** Containerization
*** splitting the code into different services and dockerizing them helps separate different logic in the code and update services separately (without having to restart the entire program)
** Container Orchestration
*** use kubernetes or docker swarm to orchestrate the different nodes, pods, and services
*** people should be easily be able to connect as a worker node
*** built-in node failure handling may be able to handle disconnections?
*** limiting cpu/mem usage of pods may be able to let program run in background without disturbing other applications, allowing for longer runs?
*** built-in load balancing tools and scaling of pods may have performance benefits
** Caching
*** right now everything resolves around a master node, a MySQL database, and worker nodes
*** database read/writes are slow, perhaps looking into an in-memory cache like Redis may greatly improve efficiency
** Database Improvements
*** structure the database better and optimize queries
** Message/Work Queues
*** use message/work queues with something like RabbitMQ to optimize process of notifying workers of new tasks
** AI Optimization
*** look into how to increase the efficiency of mutating/mating individuals
*** explore if there are any optimizations for training and calculating the scores of each individual
*** perhaps get some funding to get AI-specialized GPUs? I know there is one that uses light to do matrix operations in O(1) time
* ezCGP
** More Layer Types
*** adapt more tensorflow-keras layers to ezCGP
** Multiple Connections
*** we haven't yet leveraged the power of the "cartesian" graph part of ezCGP
*** right now each node in the graph (layers) can only accept input from one other layer
** Analyzing Results
*** why are so many pareto optimal trees so linear?
*** getting more individuals, more generations, better results
** Mutation/Mating
*** implement better mutation/mating algorithms to get better individuals

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Brainstorm team ideas for the fall semester.
|Complete
|August 23, 2021
|August 30, 2021
|August 30, 2021
|}

== Self Evaluation ==
[[files/kzheng74_VIP_AAD_notebook_rubric.docx|alt=Self Evaluation|none|thumb|Self Evaluation]]

== April 26, 2021 ==
* Seeding
** My Solution
*** use a python webscraper to pull the code from tensorflow's github page
*** clean the files by removing all comments
*** parse through each file's code, recording which file requires what layers into a dictionary
*** get data on each layer by going through the dictionary and recording how many files each layer type is found in (occurrences) and how many other layer types are in the files they are in (uniqueness)
*** plot data using numpy
*** https://github.com/ezCGP/ezCGP/commit/4bd07532da28cf87f2af70d808e6396ae9aa35e6
*** [[files/layer_type_plot.png]]
* Explanation of Graph
** Occurrence Count
*** occurrence count is how many models a layer type exists in
*** higher occurrence count is better, because that means that layer can be reused on many other models
** uniqueness is on average how many other layer types exists in the models a particular layer type exists in
*** lower uniqueness count is better, because that means fewer other layer types have to be implemented to get models to work
** Simple Example
*** assume that there are models 1, 2, and 3, and layer types A, B, C, and D
*** model 1 contains layers A, B, C
*** model 2 contains layers B, D
*** model 3 contains layers A, C, D
*** in this case, A has an occurrence count of 2 (because it exists in models 1 and 3) and uniqueness of 3 ( (3+3)/2 )
*** B has an occurrence count of 2 (because it exists in models 1 and 3) and uniqueness of 2.5 ( (3+2)/2 )
* Future Plans
** get more familiar with neural network layers and how they work
** next semester, implement some of them and import some pretrained models into ezCGP
** do some multithreading work and possibly implement a worker-master setup like EMADE has into ezCGP, for faster runs, more generations, better results
* Final Presentations
** create my slide for final presentation on Friday
** practice for the presentation

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Finish Seeding visualization slide
|Complete
|April 19, 2021
|April 24, 2021
|April 26, 2021
|}

== April 19, 2021 ==
* Seeding
** Problem
*** want to import pre-trained image classification neural network models from tensorflow, only one (VGG16) is currently implemented
*** https://github.com/tensorflow/tensorflow/tree/v2.4.1/tensorflow/python/keras/applications
*** to import said models, we need to "translate" the layers (conv2D, maxPooling2D, BatchNormalization, etc.) into ezCGP
*** there are many different kinds of layers, which ones to implement first?
** self-assigned to study seeding in more detail
* Visualization
** helped teammate add parameter names to each node (instead of just parameter indices representing their position in the individual's parameter list)
** this allows us to see what parameters are actually being passed into each node and evaluate how those might affect the result
** [[files/exampleviz2.png]]

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Understand how neural networks and their layers work
|In Progress
|April 19, 2021
|
|Next Semester
|-
|Read through the code in tensorflow's image classification models
|Complete
|April 19, 2021
|April 24, 2021
|April 26, 2021
|-
|Figure out which layer types to implement first
|Complete
|April 19, 2021
|April 23, 2021
|April 26, 2021
|}

== April 12, 2021 ==
* Visualization
** I added visualization support for inactive nodes
** this allows us to see what nodes are not being used, and think about why they might not have been chosen in the pareto optimal individual
** also helps us see how nodes in an individual are connected together, how complex they are, 
** https://github.com/ezCGP/ezCGP/commit/16a9bfe1ee93c4bab6fdc848c31799953349797c
** [[files/inactive_nodes_shown.png]]
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Add parameter names to visualized individual tree
|Complete
|April 12, 2021
|April 18, 2021
|April 19, 2021
|}

== April 8, 2021 ==
'''Team Meeting Notes'''
* Visualization Issues
** view node number
** view parameter names
** view inactive nodes
** assigned to show inactive nodes a particular individual's graph
** currently, only the input, active nodes, and fitness output nodes are shown as just a linked list, which is not representative of what actually happens in ezCGP

{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Print inactive nodes given a flag
|Completed
|April 8, 2021
|April 12, 2021
|April 12, 2021
|-
|Find inactive nodes in an individual's genome
|Completed
|April 8, 2021
|April 12, 2021
|April 12, 2021
|-
|Add flag to argparse (-v) setting whether to show inactive nodes or not
|Completed
|April 8, 2021
|April 12, 2021
|April 12, 2021
|-
|View full individual (in both show inactive nodes and don't show) modes on draw.io
|Completed
|April 8, 2021
|April 12, 2021
|April 12, 2021
|-
|Merge feature with current team's branch
|Completed
|April 8, 2021
|April 12, 2021
|April 12, 2021
|-
|}

== April 5, 2021 ==
'''Team Meeting Notes'''
* ezCGP
** play around with 
** get some individuals to test the visualization tool by running ezCGP on PACE

'''Action Items'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Understand how the visualization code prints an individual
|Completed
|April 5, 2021
|April 8, 2021
|April 12, 2021
|-
|Understand how an individual is made up of blocks
|In Progress
|April 5, 2021
|
|April 19, 2021
|-
|Understand how the blocks are made up of individual nodes that can feed into one another
|In Progress
|April 5, 2021
|
|April 19, 2021
|-
|Understand how the program is seeded with individuals
|In Progress
|April 5, 2021
|
|April 19, 2021
|-
|}

== April 1, 2021 ==
'''Team Meeting Notes'''
* Goals
** Focus on getting everyone set up on github
** Get set up on PACE-ICE
* About ezCGP
** each individual has a list of nodes, which can be turned on or off

'''Action Items'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Get one run done on PACE-ICE
|Completed
|April 1, 2021
|April 4, 2021
|April 5, 2021
|-
|SSH into PACE-ICE
|Completed
|April 1, 2021
|April 2, 2021
|April 5, 221
|-
|Clone ezCGP github onto personal PACE-ICE server
|Completed
|April 1, 2021
|April 4, 2021
|April 5, 2021
|-
|Set up conda environment in PACE-ICE
|Completed
|March 29, 2021
|April 4, 2021
|April 5, 2021
|-
|}

== March 29, 2021 ==
'''Team Meeting Notes'''
* Assigned to the group ezCGP

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Set up ezCGP production environment
|Completed
|March 29, 2021
|April 4, 2021
|April 5, 2021
|-
|Clone ezCGP github
|Completed
|March 29, 2021
|March 31, 2021
|April 5, 221
|-
|Clone ezCGP github
|Completed
|March 29, 2021
|March 31, 2021
|April 5, 2021
|-
|Set up conda environment
|Completed
|March 29, 2021
|April 1, 2021
|April 5, 2021
|-
|Get one successful run on local machine
|Completed
|March 29, 2021
|April 4, 2021
|April 5, 2021
|-
|}

== March 22, 2021 ==
'''Team Meeting Notes:'''
* Market Analysis and Portfolio Optimization
** Goals
*** use technical indicators to predict stock trends and buy/sell stocks optimally
*** use EMADE to improve existing trading algorithms
** Research
*** find research papers on stock prediction with genetic programming and ML
*** re-create existing trading models in EMADE
*** generate a model through EMADE that outperforms that in the paper(s)
** Technical Indicators (TI)
*** On Balance Volume (OBV), Chalkin Money Flow (CMF), Volume Price Trend (VPT), etc.
** First Semester Students
*** create own Technical Indicator Primitives for EMADE, by hand and with the TA-lib library
*** researching TI's from papers and adapting them to EMADE
*** assist EMADE runs by joining as workers
*** help analyze EMADE results and compare with the basis paper
* ezCGP
** Easy Cartesian Genetic Programming
** is a graph-based structure instead of tree-based like DEAP
** Key Features
*** directed acyclic graphs (DAGs) of primitives
*** reuse of nodes (the output of one node can be reused by multiple primitives)
*** can turn nodes on and off
*** designing a custom framework (kinda unrelated to EMADE and DEAP)
** Block Structure
*** separates data preprocessing and data classification
*** an individual is a single genome broken into a number of blocks
*** types of blocks includes data augmentation, data preprocessing, model training, and analysis blocks
** CIFAR10
*** image classification dataset
*** used to practice and improve the ezCGP framework
** Ongoing Research
*** transformers and RNN
* Modularity
** Goals
*** abstracts part of individuals, allowing "building blocks" to be created
*** helps with reuse blocks of code
** Adaptive Representation through Learning (ARL)
*** introduces more modularity and reusability 
*** once a "good" section of a tree is found, you can make it into a new primitive
*** hopefully this primitive can now be used by other individuals in the population
*** possible advantages include populations might converge faster and destructive changes (mutation on a very fit individual) might be prevented
** How It Works
*** search population for combinations of parents and children nodes that modifies the data
*** select some combinations (the "good" branches) based on their frequency
*** abstract these combinations into a single node (a primitive, basically)
*** these ARLs can't be changed but can be wrapped around and used by other trees
** Research
*** adding more complexity to current ARLs (adding all subtrees, genetic duplicates, etc.)
*** documenting code with Sphinx
*** database storage
* NLP
** natural language processing
** Goals
*** evolutionary approach to NLP with neural architecture search using EMADE
*** focus on looking at related research papers
** Research
*** using Kaggle dataset of user reviews on products on Amazon
*** figure out which ML algorithms work best for NLP
*** binary classification (positive or negative reviews)
*** in the future, need to add functionality to find failure-prone primitives and trivial solutions
*** use pytorch, keras, tensorflow
*** get completed runs on the Amazon dataset
** PACE_ICE
*** standardized runs (shared environment and OS's)
*** pros: free GPU, easy first-time setup
*** cons: runtime limited to 8 hours, but a deeper learning curve, and unresolved database errors
** FastText Model
*** the tree model used by EMADE ran into some concatenation errors
*** a new model was needed -- the FastText model

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Decide which teams I want to join
|In Progress
|March 22, 2021
|
|March 29, 2021
|-
|}

== March 17, 2021 ==
'''Team Meeting Notes:'''
* EMADE
** a few other team members were able to connect to the AWS server
** I ran as the master process, 3 others ran as worker processes
** [[files/Input_titanic_AWS_server.xml|alt=input_titanic.xml for group's AWS server|none|thumb|input_titanic.xml for group's AWS server]]
** let it run until it hit its max (elements in queue not decreasing for many days)
** ran till 220 elements remaining in year 19
** pulled results:
*** Pareto Front Graph
*** [[files/EMADE_multiple_worker_pareto_front_graph.jpeg|alt=Pareto Front Graph for EMADE|none|thumb|Pareto Front Graph for EMADE]]
*** Pareto Individuals Per Generation:
*** [[files/EMADE_multiple_worker_pareto_individuals.png|alt=Pareto Individuals Per Generation|none|thumb|Pareto Individuals Per Generation]]
* Presentation
** created a presentation for final bootcamp presentation session
** assigned to present MOGP results and EMADE installation

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Run emade as master process with other teammates as worker processes
|Complete
|March 17, 2021
|March 19, 2021
|March 22, 2021
|-
|Pull results from 19-year run
|Complete
|March 17, 2021
|March 20, 2021
|March 22, 2021
|-
|Finish presentation slides
|Complete
|March 17, 2021
|March 21, 2021
|March 22, 2021
|-
|Do a practice presentation with teammates
|Complete
|March 20, 2021
|March 22, 2021
|March 22, 2021
|-
|}

== March 10, 2021 ==
'''Team Meeting Notes:'''
* MySQL
** teammates having trouble connecting
** issues appear to be with the firewall blocking port 3306
* EMADE
** Ran emade multiple times on my own with two local worker processes
** Made it to year 11 with 299 elements remaining in the queue
** Appears that more worker processes are necessary to make it to more years
** Results:
*** [[files/EMADE_individual_pareto_front.png|alt=EMADE Pareto Front for Individual Run|none|thumb|EMADE Pareto Front for Individual Run]]
** CSV of all individuals:
*** [[files/EMADE_solo_individuals.csv|alt=EMADE All Individuals for Individual Run|none|thumb|EMADE All Individuals for Individual Run]]
** Pareto Individuals:
*** [[files/EMADE_solo_pareto.csv|alt=EMADE Pareto Individuals for Individual Run|none|thumb|EMADE Pareto Individuals for Individual Run]]
** Titanic Data Preprocessing:
*** [[files/EMADE_titanic_data_splitter.txt|alt=EMADE Data Preprocessing|none|thumb|EMADE Data Preprocessing]]

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Get team members to connect to database
|Complete
|March 10, 2021
|March 14, 2021
|March 17, 2021
|-
|Set up AWS Lightsail server with mysql database
|Complete
|March 10, 2021
|March 14, 2021
|March 17, 2021
|-
|Resolve firewall issues on AWS server or local computer
|Complete
|March 10, 2021
|March 14, 2021
|March 17, 2021
|-
|Figure out how to implement our own data preprocessing
|Complete
|March 10, 2021
|March 17, 2021
|March 17, 2021
|-
|Run EMADE more on local computer
|Complete
|March 10, 2021
|March 17, 2021
|March 17, 2021
|-
|}

== March 3, 2021 ==
'''Team Meeting Notes:'''
* Run EMADE
** python src/GPFramework/launchGTMOEP.py templates/input_titanic.xml
* Database Configuration
** if running locally, server can be on localhost or 127.0.0.1
** username and password are for mysql, the user (root) should have full permissions on the database specified
** username and password will be in plaintext
** make database outside of emade through mysql
* Datasets
** emade can run across multiple datasets
** the data is preprocessed into gzipped csv files
** if cross folded multiple times, this will create multiple trials that the algorithms can be scored with
** each train and test file creates a DataPair object in emade
** each row corresponds to an instance (person in Titanic, for example)
** each column is a feature of the instance
** final column is truth values (expected output)
* Objectives
** names will be used as columns in the database
** weight specifies if its supposed to be minimized (-1.0) or maximized (1.0)
* Parameters
** evalFunctions tells the program where to find the evaluation methods
** memory limit -- each individual has a memory cap
** workersPerHost -- how many jobs to evaluate in parallel
*** keep to just 2-3 for a laptop
* Evolution Paremeters
** mutation, mating, etc.
* Worker
** to run as worker add "-w" to the initial command
 
'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Clone emade from the github
|Complete
|March 3, 2021
|March 7, 2021
|March 10, 2021
|-
|Set up the input_titanic.xml file
|Complete
|March 3, 2021
|March 9, 2021
|March 10, 2021
|-
|Set up mysql database
|Complete
|March 3, 2021
|March 9, 2021
|March 10, 2021
|-
|Run emade as the master process
|Complete
|March 3, 2021
|March 9, 2021
|March 10, 2021
|-
|}

== Feb 24, 2021 ==
'''Team Meeting Notes:'''
* Present our presentations on using MOGP on Kaggle's Titanic dataset.

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Install EMADE
|In Progress
|Feb 24, 2021
|March 3, 2021
|March 3, 2021
|-
|}

== Feb 23, 2021 ==
'''Subteam Meeting Notes:'''
* Finish work on our presentation slides
* Run through them a couple times

== Feb 21, 2021 ==
'''Subteam Meeting Notes:'''
* Compare our MOGP programs and make them pareto optimal.
* Begin work on the presentation.
* Personal GP results:
[[files/Titanic_MOGP_Pareto_Front.png|alt=Pareto Front Graph for Titanic GP|none|thumb|Pareto Front Graph for Titanic GP]]

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Finish our MOGP programs
|Completed
|Feb 21, 2021
|Feb 23, 2021
|Feb 24, 2021
|-
|Set next meeting time
|Completed
|Feb 21, 2021
|Feb 21, 2021
|Feb 21, 2021
|-
|}

== Feb 20, 2021 ==
'''Subteam Meeting Notes:'''
* Share progress with team members
* I shared my evaluation function and explained how it works:
** compiles an individual's primitive tree
** for each passenger in the dataset, use their data as arguments in the individual's function, and produce a numerical result
** if the result is negative, then the function's predicting the passenger died
** if the result is positive, then the function's predicting the passenger survived
** once all the passengers have been predicted to be either dead or alive, check them against the actual result data (y)
** from here calculate the true positive, false positive, false negative, and true negative amounts
** return the false positive and false negative amounts as these are the ones we want to minimize

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Finish our MOGP programs
|Completed
|Feb 19, 2021
|Feb 20, 2021
|Feb 22, 2021
|-
|Set next meeting time
|Completed
|Feb 19, 2021
|Feb 19, 2021
|Feb 19, 2021
|-
|}

== Feb 17, 2021 ==
'''Team Meeting Notes:'''
* Using MOGP, evolve our own codominant models to solve the Titanic ML problem.
* Create a presentation on our group's data processing, models, and compare our MOGP results to the other ML models from last week.

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Create multi-objective evaluation function.
|Completed
|Feb 17, 2021
|Feb 24, 2021
|Feb 19, 2021
|-
|Research various multi-objective selection methods and choose one.
|Completed (selTournamentDCD)
|Feb 17, 2021
|Feb 24, 2021
|Feb 20, 2021
|-
|Research various mutation methods and choose one.
|Completed (mutInsert)
|Feb 17, 2021
|Feb 24, 2021
|Feb 20, 2021
|-
|Research various mating methods and choose one.
|Completed (cxOnePoint)
|Feb 17, 2021
|Feb 24, 2021
|Feb 20, 2021
|}

== Feb 16, 2021 ==
'''Team Meeting Notes'''
* shared our models and results with our subteam
* decided to drop the "Embarked" and "SibSp" columns because our feature selection results had deemed them to be the least important
* kept the "Parch" column because if we removed it, the accuracies on all our models would drop
* coordinated between team members to make all our models pareto optimal, sometimes sacrificing a little bit of accuracy
* I personally decided to go with the NuSVC model with the parameters (nu=0.61, kernel="poly", degree=2, cache_size=400) to make my model pareto optimal in relation to others
* achieved a confusion matrix of [142 TP, 5 FP, 39 FN, 37 TN] and an accuracy of 0.8026905829596412 on the test_split

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Change variables in our models to make them all pareto optimal
|Completed
|Feb 16, 2021
|Feb 17, 2021
|Feb 16, 2021
|-
|Submit Titanic ML assignment on Canvas
|Completed
|Feb 16, 2021
|Feb 17, 2021
|Feb 16, 2021
|-
|Shared the confusion matrix and accuracies for each of our group members
|Completed
|Feb 16, 2021
|Feb 17, 2021
|Feb 16, 2021
|
|}

== Feb 13,2021 ==
'''Team Meeting Notes'''
* familiarized with the Kaggle Titanic Challenge
* began the first part of the project, feature selection
* looked into three feature selection techniques: univariate selection, feature importance, and correlation matrix with a heatmap
* modified the test split size proportion from 0.3 to 0.25
* created github repository to share code
* established subteams within our subteam to implement each of the feature selection techniques

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Set next team meeting
|Completed
|Feb 13, 2021
|Feb 17, 2021
|Feb 13, 2021
|-
|Schedule the second subteam meeting
|Completed
|Feb 13, 2021
|Feb 17, 2021
|Feb 14, 2021
|-
|Implement feature importance and share results with the subteam
|Completed
|Feb 13, 2021
|Feb 17, 2021
|Feb 15, 2021
|-
|Continue researching different ML models on scikit-learn
|Completed
|Feb 13, 2021
|Feb 17, 2021
|Feb 15, 2021
|
|}

== Feb 10, 2021 ==
'''Lecture Notes'''
* introduced to the Titanic challenge on Kaggle
* looked at various data preprocessing methods including removing irrelevant columns and using a column's mean, median, or mode to fill in partially empty columns with meaningful data
* discussed some basic pre-built machine learning models available in the scikit-learn documentation
* assigned to team #1

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Join subteam's groupme and discord
|Completed
|Feb 10, 2021
|Feb 17, 2021
|Feb 11, 2021
|-
|Schedule the first subteam meeting
|Completed
|Feb 10, 2021
|Feb 17, 2021
|Feb 11, 2021
|
|}

== Feb 3, 2021 ==
'''Team Meeting Notes:'''
* The gene pool is the set of genomes to be evaluated during the current generation
** Genome
*** Genotypic description of individuals
*** organisms have DNA
*** genetic algorithms have sets of values
*** genetic programs have a tree structure which represents an equation
** Search Space
*** set of all possible genoms
* The evaluation of a genome associates a genome/individual with a set of scores
** Objectives
*** set of measurements each genome/individual is scored against
** Objective Space
*** the set of objectives
** Evaluation
*** maps a genome individual from a location in the search space (genotypic description)
*** to a location in objective space (phenotypic description)
* Confusion Matrix
** [[files/L3_Confusion_Matrix.png|alt=Confusion Matrix|none|thumb|Confusion Matrix]]
* Minimization Measures
** False Negative Rate (FNR)
*** FNR = FN/P = FN/(TP+FN)
*** FNR = 1-TPR
** Fallout or False Positive Rate (FPR)
*** FPR = FP/N = FP/(FP+TN)
*** FPR = 1-TNR = 1-SPC
* Other Measures
** Precision or Positive Predictive Value (PPV)
*** PPV = TP/(TP+FP)
*** bigger is better
** False Discovery Rate (FDR)
*** FDR = FP/(TP+FP)
*** FDR = 1-PPV
*** smaller is better
** Negative Predictive Value (NPV)
*** NPV = TN/(TN+FN)
*** bigger is better
** Accuracy (ACC)
*** ACC = (TP+TN)/(P+N)
*** ACC = (TP+TN)/(TP+TN+FN+FP)
*** bigger is better
* Pareto Optimality
** an individual is pareto optimal if there is no other individual in the population that outperforms the individual on all objectives
** the set of all pareto individuals is known as the pareto frontier
** our goal is to drive selection by favoring pareto individuals
* Nondominated Sorting Genetic Algorithm II (NSGA II)
** population is separated into nondomination ranks, then individuals are selected by tournament
** lower pareto ranks (better pareto optimality) beats higher pareto ranks
** ties on the same front are broken by crowding distance
* Strength Pareto Evolutionary Algorithm 2 (SPEA2)
** each individual has a strength S (how many others in the population it dominates)
** each individual has a rank R (r is the sum of the S's of the individuals that dominate it)
** pareto optimal individuals have an R of 0

'''Lab 2'''
Multiple Objective Genetic Programming: evolving individuals in a population to optimize for multiple, different evaluations.

Objective Space:
[[files/MultipleObjectiveObjectiveSpace.png|alt=Objective Space for Multiple Objectives|none|thumb|Objective Space for Multiple Objectives]]

Graph:
[[files/MultiObjectiveGraph.png|alt=Graph for Multiple Objectives|none|thumb|Graph for Multiple Objectives]]

Pareto Front Graph:
[[files/MultiObjectiveParetoFrontGraph.png|alt=Pareto Front Graph for Multiple Objectives|none|thumb|Pareto Front Graph for Multiple Objectives]]

To achieve a better AUC, remove the sin, cos, and tan primitives from the program.
This will achieve an AUC of 1.0148253892117132.

New Pareto Front Graph:
[[files/MultiObjectiveParetoFrontGraph2.png|alt=Better Pareto Front Graph for Multiple Objectives|none|thumb|Pareto Front Graph for Multiple Objectives]]

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Lab assignment #2: Multiple Objectives
|Completed
|Feb 3, 2021
|Feb 9, 2021
|Feb 10, 2021
|
|}

== January 27, 2021 ==
'''Team Meeting Notes:'''
* Introduction to preordered parse trees
* These trees hold operators, variables, and constants that, when read pre-ordered, form some equation.
* The equation defined by each tree is evaluated every generation, and better trees have a chance of being mated and mutated to form the next generation.
* By defining certain operators, variables, and constants, over the course of many generations, genetic programming can come to approximate functions like sin and cos.
'''Lab 2 Notes:'''
* DEAP can hold primitives (variables, operators, functions, etc.) in a special Primitive Tree that represents an equation.
* Each of the primitive functions receives lists as input and has to put back out a list/tuple as output.
* Each individual consists of one PrimitiveTree (i.e. one equation).
* Different mutation functions are available, each providing unique benefits, depending on the problem.
* As the population mates and mutates, "branches" of each individual's PrimitiveTree is swapped or changed, resulting in a new individual for the next generation.
* The most fit individuals are mated and/or mutated.
* The fitness evaluation can consider multiple variables.
* Certain individuals are considered "dominant" over another individual based on its fitness values.

'''Lab 2'''
Symbolic Regression: a genetic program which, using a PrimitiveTree of variables and operators, evolves an equation to estimate what we want in our evaluation function.

I added two new primitives to the existing operators:

     pset.addPrimitive(np.rint, arity=1)

    def power(a):
        res = list()
        for i in range(0, len(a)):
           res.append(a[i]**2)
        return res
        
     pset.addPrimitive(power, arity=1, name="power")

Through this I realized that self-defined primitive operators have to accept lists as arguments.

The results:
[[files/SymbolicRegressionResult.png|alt=Result of Symbolic Regression Program|none|thumb|Result of Symbolic Regression Program]]
[[files/SymbolicRegressionGraph.png|alt=Graph of Symbolic Regression Program|none|thumb|Graph of Symbolic Regression Program]]
'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Lab assignment #2
|In Progress
|January 27, 2021
|Feb 3, 2021
|Feb 3, 2021
|
|}

== January 20, 2021 ==
'''Team Meeting Notes:'''
* Overview of genetic programming, setup tools, and need-to-know vocabulary
* Terms: selection, mating, fitness, crossover, mutation
'''Lab 1 Notes:'''
* Genetic programming optimizes algorithms by running them through an evolutionary simulation for multiple generations.
* Python's DEAP library provides much of the tools necessary for genetic programming.
* Steps of genetic programming:
** Define various attributes
** Define what attributes an individual consists of
** Define how to evaluate each individual's fitness
** Define how two individuals can "mate" and randomly swap attributes to create children
** Define how an individual can "mutate" and randomly change attributes
** Create a population of individuals with random assortments of various attributes
** Evaluate the fitness of each individual in the population
** Select the individuals with the best fitness from the population
** Mate/mutate those chosen individuals and include them in the next generation
** Repeat for several generations
* It is very useful to graph the best fit individual in each generation so as to see the progress made during each generation.

'''Lab 1 Program:'''
One Max: a genetic algorithm which seeks to maximize the number of ones in a length-n array.
Shows the basics of defining attributes, individuals, evaluation, mutation, crossover, and selection.
[[files/OneMaxResult.png|alt=Results of OneMax Program|thumb|Results of OneMax Program|none]]

N Queens: a genetic algorithm which seeks to minimize the number of "conflicts" between n queens on an n by n chessboard (with each queen on a different row/column). A "conflict" is defined as when one queen can "take" another.

I implemented my own mutation function:
[[files/NQueensMutation.png|alt=Personal Mutation function of N Queens Problem|thumb|Personal Mutation function of N Queens Problem|none]]

The result:
[[files/NQueensResult.png|alt=Result of N Queens Program|thumb|Result of N Queens Program|none]]

'''Action Items:'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Lab assignment #1
|Completed
|January 20, 2021
|January 24, 2021
|January 24, 2021
|
|}