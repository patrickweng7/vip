== Team Member ==

Team Member: Leul Wubete
l
Email: wubete3@gatech.edu
Cell Phone: +1 4047897798

Interests: Soccer, Walking, Eating, Breathing

== September 1, 2021 (Week 2) == 

== August 25, 2021 (Week 1) == 

===Lecture Notes:===
* Introduced to project requirements:  Rubric, Syllabus, JupyterLab, Python deap, 
* Shown emade's GitHub, Wiki, Personal Progress Notebooks, Python Jupyter Notebooks, Slack
* Intro to Genetic Algorithms:
    -  The evolution and DNA of the computing world.
    -  Multiple solutions to complex problems, AKA genomes, that can mutate with other solutions given evaluation/fitness.
    -  You can do mating/mutation -> next gen, we loop the process until we find the perfect specimen.
* "Individual"
    -  One candidate in the population
    -  A single organism
* "Population"
    -  Group of individuals to be experimented upon
* "Objective"
    -  Individual's performance measurement
    -  This is like a credit score
* "Fitness"
    -  How good individual is compared to others.
* "Evaluation"
    -  Takes individual and spits out objective.
* "Selection"
    -  Gives preference to better individuals to pass on their genes
    *  2 types:
        -  I. Fitness Proportionate: fitness value is the deciding factor, most fit from all moves on.
        -  II. Tournament: given group of n individuals, most fit is selected for mating. A bit more of a real life scenario.
* "Mating"/"Crossover"
    -  mating between individuals, DNA is combined from individuals.
    -  examples: single point splice, double point splice, ... represented as python list splicing and joining.
* "Mutation"
    -  Inserting change to an individual (changing a person's DNA)
    -  Why? Keep diversity as a factor.
* Algorithms
    -  Initialize population
    -  Consider population fitness (survival of fittest)
    -  Repeat and pick the chosen one:
        1. Select parents
        2. Mating actions
        3. Mutations
        4. Determine fitness
        5. (until the best individual is acceptable)

===Lab 1 walkthrough/personal progression Notes:===
* Downloaded and installed pip for Windows 10
* pip installed jupyterLab for Windows 10
* Added python to my environment variables
* I launched JupyterLab from cmd using 'jupyter-lab' command.
* downloaded DEAP Problem from the Calendar, under the week 1 Assignments column. Saved the file as .ipynb
* Imported Lab1 .ipynb into JupyterLab via the jupyterLab file explorer GUI.
* Opened a new command prompt and used 'pip install deap' to install deap

===Lab 1 Notes:===

===oneMax===
* we defined the name of the class, the inherited class, and the objectives.
    - creator.create("FitnessMax", base.Fitness, weights=(1.0,))
      weight is the objective, if we wanted multi-objective, maybe something like (1.0, -1.0)
* Deap's toolbox
    - DEAP's toolbox.register, we generate individuals with their attributes and how many attributes each individual container should have.
* evalOneMax()
    - simple algorithm to return the # of 1's in a list.
* Genetic Operations
    - Evaluate: evalOneMax()
    - Mate: a two-point crossover function (tools.cxTwoPoint)
    - Mutate: is defined as flipping a bit in our bitstring to either 1 or 0, independent probability of flipping each individual bit of 5%.
    - Select: tournament selection of 3 individuals
* Evaluating our population
    - mapped the evaluation function, then assigning fitness by zipping individuals and their fitness together:
       fitnesses = list(map(toolbox.evaluate, pop))
       for ind, fit in zip(pop, fitnesses):
           ind.fitness.values = fit 
* Evolution process
    - After the tournament selection, clone the offspring so they do not mix with the last loop.
    - next is crossover mutation, where we zip the 2 versions of the list, one being the odd skip, the other being the even skip.
    - in the chance we generate a random < 0.5, we will be mating the two and deleting their separate fitness values.
    - mutate individuals having <20% probabilities and deleted the mutated offspring's fitness values.
    - individuals with invalid fitness in offspring will have their fitness evaluated and then given fitness values, then we set the pop to offspring.
    - found max, min, avg, and standard deviation statistics for the new pop.

===N Queens===
* A conceptually simple problem:
    - knowing that a queen can move horizontally, vertically, and diagonally, how can we stack queens on an n x n board in each row, so that no one queen 
      can reach another queen?
* Make fitness and individual classes for sample 20 x 20 board. Fitness is negative weight, why? We want to minimize conflicting queen paths.
* Individual
    -  our individual (set of Queens) becomes the return value of toolbox_q.permutation, which happens to be a list of integers sampled from range(n) 
       without replacement.
    - If n = 10, then an individual could look like this: [7,0,4,6,5,1,9,2,8,3]. If the first integer in the list is 7, then the queen on the first row 
      will be in column 8.
* Diagonals:
    - Ledt/Right diagonals: https://media.geeksforgeeks.org/wp-content/cdn-uploads/20200510152131/TopLeftBD.jpg
    - Count queens on each diagonal for evalNQueens(individual), and sum the total number of conflicts on L/R diagonals.
* Partially matched crossover:
    - is specifically used in this problem because it represents swapping around pairs of queen positions between two-parent individuals. 
    - This should be more effective than swapping pieces of individuals around like in a one or two-point
    - If we swapped half of the chessboard we would not retain the information gained from either parent because the individual is formed row by row.
    - Chose two random crossover pts then swap the individuals' bits between their indices.
    -  Two Point crossover is also available.
    - x = / next line code is just a way to continue writing value assignment on the next line.
* My mutation function that includes the equivalently counted index from swap_indx, from the opposite end of the list where swap_indx resides.
    def myMutation(individual, indpb):
    size = len(individual)
    
    for i in range(size):
        if random.random() < indpb:
            swap_idx = random.randint(0, size - 2)
            if swap_idx >= i:
                swap_idx += 1
            # swap_opp(opposite) should be at the opposite side of swap_idx
            swap_opp = size - 1 - swap_idx
            if swap_idx != swap_opp:
                individual[i], individual[swap_opp], individual[swap_idx] = \
                    individual[swap_opp], individual[swap_idx], individual[i]
            else:
                 individual[i], individual[swap_idx] = \
                individual[swap_idx], individual[i]
            
    return individual, 
* functions for evaluate -> evalNQueens(), mating -> cxPartiallyMatched, mutate -> indpb = 2.0/n, selection -> tournament with 3 in an arena.
* evolutionary cycle, as shown in lecture.
* pip installed matplotlib

* my mutation (myMutation()) function results:
    - 0 min fitness on gen. 24
    - 0 min fitness on gen. 52
    - 0 min fitness not obtained in first 100 generations
    - 0 min fitness on gen. 31

* mutShuffleIndexes() function results:
    - 0 min fitness on gen. 91
    - 0 min fitness not obtained in first 100 generations
    - 0 min fitness on gen. 11
    - 0 min fitness not obtained in first 100 generations

===Lab 2 Notes:===
* Genetic Programming:
    - Tool used for automated algorithm design. Just like genetic algorithms, we still need fitness and individual classes.

* Instead of lists that we use for genetic algorithms, we use what data structure?
    - gp.PrimitiveTree, individuals represented as a tree structure

* Trees are made of?
    - functions and variables are called primitives AKA the normal nodes.
    - Terminals are the leaf nodes.
    - Root node is considered primitive.

* How to add math operations and rename default arguments? How to add primitives?
    a. pset.addPrimitive(np.subtract, arity=2), BY THE WAY, arity is the number of arguments an operation will take.
    b. pset.renameArguments(ARG0='x')
    c. pset.addPrimitive()

* What else should we not forget in the setup process?
    - Next we will define our toolbox, individual, population, and compiler.
    - This time, we have an expr function: gp.genHaldandHalf returns a primitive tree based on a primitive set and a minimum and maximum tree depth.
    - In this case, the primitive set is the one we defined earlier, the minimum depth is 1, and the maximum depth is 2.     

* How to optimize the function we are generating?
   - by minimizing mean squared error.
   - the mean squared error between the function we compile and the actual function we are trying to generate
   - you could think of genetic programming as finding the best combination of primitives given objectives to minimize or maximize.
   - This means we care a lot less about data than machine learning and care more about objectives.

* How did I add a new mutation function?
   - went to GP mutations in the DEAP source code here: https://github.com/DEAP/deap/blob/master/deap/gp.py
   - picked:  gp.mutEphemeral
   - added: toolbox.register("mutate_2", gp.mutEphemeral, expr=toolbox.expr_mut, pset=pset)

* How to add tree height constraints?
   - toolbox.decorate("mate", gp.staticLimit(key=operator.attrgetter("height"), max_value=17))

* How are the generations printed differently from our evolutionary algorithm?
   - they are printed from the the structure of the tree, read left to right

==== Multiple Objective Genetic Programming ====

* Remember, multiobjective genetic programming has more than one:
   - Weights!
* Plotting class?
   - import matplotlib.pyplot as plt
* Where to visit for Pareto front/dominance?
   - https://github.com/lmarti/evolutionary-computation-course/blob/master/AEC.06%20-%20Evolutionary%20Multi-Objective%20Optimization.ipynb

==== Lab 2 conclusions and issues ====
* I still do not have access or full know-how of how to upload pictures to my Wiki
* My process included changing my git username and email address on my command prompt. When I try to clone the Wiki
* I get an error claiming my PC's space is too low for the wiki's
* When I try to commit the first time, it claims that it is ready to delete all the current pictures/wikis uploaded to EMADE, not good.

===Action Items:===
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Set up personal notebook page
|Completed
|August 27, 2021
|September 1, 2021
|August 27, 2021
|-
|Join Slack
|Completed
|August 25, 2021
|September 1, 2021
|August 27, 2021
|-
|Complete "Lab 1 - Genetic Algorithms with DEAP.ipynb" with JupyterLab
|Completed
|August 25, 2021
|September 1, 2021
|August 30, 2021
|-
|Complete "Lab 2 - Genetic Programming and Multi-Objective Optimization.ipynb" with JupyterLab
|Completed
|September 5, 2021
|September 1, 2021
|September 8, 2021
|}
