'''Name:''' Rohan Batra

'''Email:''' [mailto:rbatra34@gatech.edu]

'''Cell Phone:''' 470-909-8524

'''VIP:''' Automated Algorithm Design

'''Interests:''' Artificial Intelligence, Machine Learning, Soccer, Guitar

= Fall 2021 =
== Week 3: September 8th - September 15th (2021) == 
===Outline of class notes===

'''In class:'''
* Discussed 'Multiple Objectives ‚Äì The MO in MOGA and MOGP'
* Overview of the Pareto Optimality 
* Rated our Python and ML Skills

'''Lecture Notes:'''
* Had an open discussion about what an algorithm looks for in a mate. There are a variety of objectives that we aim to achieve by generating specific algorithms to the get the best solution. Specificity, precision, accuracy, etc. are few important characteristics/goals that we aim to achieve.
* <b>Genetic Programming Cycle:</b> New Gene Pool ‚Üí Evaluation ‚Üí Genes with scores ‚Üí Fitness Computation ‚Üí Genes with fitness ‚Üí Selection ‚Üí Parental Genes ‚Üí Mating ‚Üí Child Genes ‚Üí Mutation ‚Üí New Gene Pool
* Keywords:
** Gene pool: The set of genome to be evaluated during the current generation
** Genome: Genotypic description of an individuals (DNA, GA = set of values, GP = tree structure, string)
** Search Space: Set of all possible genome. For Automated Algorithm Design it's the set of all possible algorithms
** The Evaluation of a Genome: Associates a genome/individual (set of parameters for GA or string for GP) with a set of scores.
*** From a location in search space: Genotypic description
*** To a location in objective space: Phenotype description
* <b>Important measures for multi objectivity: </b>
** True Positive ‚Äì TP: How often are we identifying the desired object
** False Positive ‚Äì FP: How often are we identifying something else as the desired object
** True Negative - TN: How often are we identifying the non-desired object
** False Negative - FN: How often are we identifying the desired object as something else
** Objectives: Set of measurements each genome (or individual) is scored against
** Objective Space: Set of objectives 
* Confusion Matrices use TP, FP, TN, FN to visualize outcomes.
* Other measures that we use for optimization and prediction:
** Sensitivity or True Positive Rate (TPR): AKA hit rate or recall, TPR = TP/P = TP/(TP+FN)
** Specificity (SPC) or True Negative Rate (TNR): TNR = TN/N = TN/(TN+FP)
** False Negative Rate (FNR):FNR = FN/P = FN/(TP+FN), FNR = 1 - TPR
** Fallout or False Positive Rate (FPR): FPR = FP/N = TN/(FP+TN), FPR = 1 ‚Äì TNR = 1 - SPC
** Precision or Positive Predictive Value (PPV), PPV = TP / (TP + FP), Bigger is better
** False Discovery Rate, FDR = FP/(TP + FP), FDR = 1 - PPV, Smaller is better
** Negative Predictive Value (NPV), NPV = TN / (TN + FN), Bigger is better
** Accuracy (ACC), ACC = (TP+TN) / (P+N), ACC = (TP+TN) / ( TP + FP + FN + TN),  Bigger is better
** Objective Space:Each individual is evaluated using objective functions like Mean squared error, Cost, Complexity, True positive rate etc.
** Objective scores give each individual a point in objective space
** This may be referred to as the phenotype of the individual 
* All these measures help us in selecting the right algorithms, mating, fitness computation etc.
* <b>Pareto Optimality</b>
** An individual is Pareto optimal if there is no other individual in the population that outperforms the individual on all objectives
** The set of all Pareto individuals is known as <i>the Pareto frontier.</i>
** These individuals represent unique contributions. We want to drive selection by favoring Pareto individuals (But maintain diversity by giving all individuals some probability of mating).
* Two types of Multi objectivity algorithms:
** Non-dominated Sorting Genetic Algorithm II (NSGA II)
*** Population is separated into non-domination (nothing over performs it at all individuals and that is why it called Pareto optimal) ranks. Individuals are selected using a binary tournament and a lower Pareto ranks beat higher Pareto ranks.
*** Ties on the same front are broken by crowding distance (more diversity is better) (its better if points are pareto optimals but a little far from one another). Summation of normalized Euclidian distances to all points within the front. Higher crowding distance wins
** Strength Pareto Evolutionary Algorithm 2 (SPEA2)
*** Each individual is given a strength S and receives a rank R. S refers to the number of others in the population that it dominates and R refers to the sum of S‚Äôs of the individuals that dominate it. Pareto individuals are nondominated and receive an R of 0.
*** A distance to the kth nearest neighbor (ùõîk) is calculated and a fitness of R + 1/(ùõîk + 2) is obtained

'''<i>Action Items</i>'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Update lecture notes
|Completed
|September 8th, 2021
|September th, 2021
|September 11th, 2021
|-
|Review lecture slides
|Completed
|September 8th, 2021
|September th, 2021
|September 10t, 2021
|-
|Complete Self-Evaluation Form
|Completed
|September 8th, 2021
|September th, 2021
|September 10th, 2021
|- 
|Complete Lab 2 (Part 2)
|In Progress
|September 8th, 2021
|September 15th, 2021
|September th, 2021
|}

== Week 2: September 1st - September 8th (2021) == 
===Outline of class notes===

'''In class:'''
* Overview of Genetic Programming.
* Learnt about Tree Representation.
* Briefly discussed Crossover and Mutation in Genetic Programming and Symbolic Regression.

'''Lecture Notes:'''
* Did a brief review of last week's material regarding Genetic Algorithms.
* Instead of taking an individual and having a function evaluator to obtain objective scores, the individual will be the function itself.
* Discussed one of the most common program structures in genetic programming, <b>Tree Representation</b>. Went over its uses and how to traverse over this tree. Parts of tree representation:
** Nodes are called primitives and represent functions, eg: +, -, x, /.
** Leaves are called terminals and represent parameters. The input can be thought of as a particular type of terminal. The output is produced at the root of the tree.
* To store the tree, the tree is converted to a lisp preordered parse tree and the order is determined by the inputs, so we use the root first and then go down.
* For example, if we use the following representation, we can determine how to traverse through the tree to determine the function by going top down and left to right.
[[files/TreeRepresentation1.png]]

So for this tree representation the function will be, f(x) = 3 * 4 + 1 and the parse would be [+,*,3,4,1].
* Crossover in tree-based GP is simply done by exchanging subtrees. Start by randomly picking a point in each tree and then these points and everything below create subtrees.
* The function with the best output mate and then produce the next generation of children.
* We also use the root sum (mean) square error method to calculate the optimized output and algorithms.
* Mutation can involve and is done by:
** Inserting a node or subtree
** Deleting a node or subtree
** Changing a node
* Learned more about the example of Symbolic Regression.
* Symbolic Regression is an example involving the mutation of GP that is used to evolve solutions using primitives.
* For instance: We use primitives like sin function, factorial, cos function, tan function, exponential, summation to evolve a solution to y = sin(x) by using the Taylor Series formula for sin(x).
* Finally we discussed that to evaluate the tree, we can measure the difference between the truth and the output that we obtain after feeding the a number of input points into the function to get outputs and then running f(x).

===LAB 2: Symbolic Regression===
* Tried to derive/inherit individuals from DEAP's PrimitiveTree instead of lists.
* Added primitives to the primitive set and chose a new mutation to find the most optimized solution.
* Compiled the primitive tree to generate the evaluation function, which finds the squared sum of the difference between our desired function's output and our individual's output. In this case we are trying to find minimum values that approaches zero faster.
* I tried modifying the code in three different ways:
** <u>The original program</u>:
***original lab 2

***First Attempt: Best individual is add(add(negative(negative(multiply(x, x))), multiply(subtract(multiply(x, x), negative(x)), multiply(x, x))), x), (1.0123748708878107e-16,)
***Second Attempt: Best individual is add(add(add(multiply(add(multiply(multiply(x, x), x), multiply(x, x)), x), multiply(x, x)), x), subtract(x, x)), (8.59033944318508e-17,)
***Depicts requirement for a more optimized and consistent solution to obtain minimum efficiently.
** <u>Program with added mutation</u>

***First Mutation (mutInsert): Best individual is add(multiply(x, add(add(multiply(x, multiply(x, x)), x), multiply(x, negative(negative(x))))), x), (1.1585916677755867e-16,)

***part2lab 2....Even after running the code for a number of times the error is lesser and the solution is more consistent and optimized than the original program.

***Second Mutation (mutShrink): Best individual is add(add(multiply(x, x), multiply(x, multiply(x, x))), add(x, multiply(x, multiply(multiply(x, x), x)))), (9.522005638492831e-17,)

***part2lab21....Values were usually close to zero, but in some cases the value was very high (for maximum) and not as consistent. 
** <u>Program with only added primitives</u>

***extralab2

*** Best individual is add(add(multiply(x, x), multiply(multiply(add(square(x), x), x), x)), x), (1.0172711918255375e-16,)

** <u>Program with both added primitives and mutation</u>
*** We used the mutInsert mutation as it seemed more consistent.

*** First pair of primitives (sin and square): Best individual is add(x, add(multiply(add(x, square(x)), multiply(x, x)), multiply(x, x))), (1.0123748708878107e-16,)

***lab2primitive1

***Second pair of primitives (absolute, cos): Best individual is add(add(cos(add(cos(subtract(x, x), cos(add(negative(x), subtract(x, negative(multiply(x, x)))), x)), x), x), cos(subtract(x, x), x)), add(x, x)), (0.0,)
***finallab2

<b>In this lab, I attempted to reduce error to bring it almost to zero. This can be seen best in the graph where I used the absolute and cos primitives with the mutInsert mutation.</b>

'''<i>Action Items</i>'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Update lecture notes (GP)
|Completed
|September 1st, 2021
|September 8th, 2021
|September 2nd, 2021
|-
|Review lecture slides
|Completed
|September 1st, 2021
|September 8th, 2021
|September 1st, 2021
|- 
|Complete Lab 2 (Part1)
|Completed
|September 1st, 2021
|September 8th, 2021
|September 4th, 2021
|}

== Week 1: August 25th - September 1st (2021) ==

===Outline of class notes===

'''In class:'''

* Overview of Automated Algorithm Design Wiki, syllabus, notebooks, etc.
* Started lecture on Genetic Algorithms.
* Briefly discussed the One Max Problem.

'''Lecture Notes:'''

* <u> The Concept </u>
** With genetic algorithms, each new generation is created through mating/mutation of individuals in the previous population  
** Their fitness is evaluated before mating/mutation.
** This fitness evaluation is done through the Fitness Proportionate method (randomization) or tournament method.
** Through numerous operations of the different processes, it will eventually produce the best individual 

* <u>Important Keywords</u>
** Algorithms: various evolutionary algorithms to create a solution or best individual.
** Individual: One specific candidate in the population (with properties such as DNA). In terms of programming this can be seen as a single solution to a problem.
** Population: Group of individuals whose properties will be altered. This refers to a number of solutions (set) for a problem.
** Objective: A value used to characterize individuals that you are trying to maximize or minimize. Usually the goal is to increase objective through the evolutionary algorithm.
** Fitness: Relative comparison to other individuals of the population.
** Evaluation: A function that computes the objective of an individual.
** Selection: This represents ‚Äòsurvival of the fittest'. Preference given to better individuals, therefore allowing them to pass on their genes.
*** Fitness Proportionate: The greater the fitness value, the higher the probability of being selected for mating.
*** Tournament: Several tournament style competitions among various individuals. Winner selected for mating.
** Mate/Crossover: Represents mating between individuals.
** Mutate: Introduce random modification. The purpose is to maintain diversity.

* <u>The Process:</u>
** Randomly initialize population
** Determine fitness of population
** Select parents from population
** Perform crossover on parents creating population
** Perform mutation of population
** Determine fitness of population
** Repeat until best individual is good enough

===Lab 1: Genetic Algorithms with DEAP===

'''One Max Problem:''' This is a simple genetic algorithm problem and its objective is to convert all 0's and 1's in a vector/bitstring to all 1's. The outline and process completed is as follows (as per steps followed in the DEAP Python notebook):
* Imported the required modules (mostly DEAP tools)
* Defined individual classes, the fitness objective, and functions using DEAP's ToolBox.
* Represented bit string individuals as Booleans.
* Evaluated the population, ran the code repeatedly, performed tournament selection, mating, and mutation.
** Mating: Two-point crossover function
** Mutate: Flipping a bit in our bit string to either 1 or 0 respectively with an independent probability of flipping each individual bit of 5%.
* Ran the algorithm for 40 generations.
* <u>Conclusion:</u> Global maximum fitness of 100.0 was usually achieved in 40 generations but sometimes this was not the case; however, the maximum fitness obtained was always very close to 100.0. This method of tournament selection among 3 individuals is better than random search.

'''The N Queens Problem:''' The problem is to determine a configuration of n queens on a nxn chessboard such that no queen can be taken by one another. In this version, each queen is assigned to one column, and only one queen can be on each line. The outline and process completed is as follows (as per steps followed in the DEAP Python notebook):
* Imported the required modules (mostly DEAP tools)
* Defined individual classes, the fitness objective, and functions using DEAP's ToolBox.
* The fitness objective is to minimize the number of conflicts between 2 queens on the chessboard. Used to range function as well.
* Defined a function called "permutation" to help create our individuals and population and others like Evaluation (minimize diagonal conflicts), Selection (tournament selection of 3 individuals), Crossover (partially matched), and Mutation (shuffle indexes) functions.
* Ran main evolutionary loop for 100 generations. 
* Current algorithm did not always achieve the global minimum (0.0) but was consistently close.
* Visualization done to achieve more efficiency and speed using graphs as follows (100 generations graph):
[[files/N Queens Problem Visualization.png|center|thumb]]
* Iterations can be reduced with change is parameters and functions. This is clear as we can see that the minimum is easily obtained around the 25th generation. I am trying to work on making few changes in the algorithm for improved results by changing the mutation and mating probabilities.

For both problems we also found the basic statistics such as mean, minimum, maximum, and standard deviation, which helped to show that the final required output could be obtained in earlier generations itself with some tweaks made in the code.


'''<i>Action Items</i>'''
{| class="wikitable"
!Task
!Current Status
!Date Assigned
!Suspense Date
!Date Resolved
|-
|Install and set up DEAP library for Python
|Completed
|August 25th, 2021
|September 1st, 2021
|August 26th, 2021
|-
|Begin Notebook
|Completed
|August 25th, 2021
|September 1st, 2021
|August 25th, 2021
|- 
|Review Slides
|Completed
|August 25th, 2021
|September 1st, 2021
|August 26th, 2021
|-
|Complete Lab 1
|Completed
|August 25th, 2021
|September 1st, 2021
|August 29th, 2021
|}









